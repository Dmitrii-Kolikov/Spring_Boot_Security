# Spring Boot Registration and Login
1. [Интеграционный тест для JPA используя @DataJpaTest](#introduction)
    1. [@AutoConfigureDataJpa](#introduction1)
    2. [@AutoConfigureTestDatabase](#introduction2)
    3. [@AutoConfigureCache](#introduction3)
    4. [@AutoConfigureTestEntityManager](#introduction4)
    5. [@Transactional](#introduction5)
    6. [@RollBack](#introduction6)
2. [Security](#security)
    1. [UserDetails](#security1)
    2. [UserDetailsService](#security2)
3.  [JPQL](#jpql)


## 1 Интеграционный тест для JPA используя @DataJpaTest <a name="introduction"></a>

***Интеграционные тесты*** — это хлеб и масло Spring. В нем, вообщем-то, все так здорово сделано для интеграционного тестирования, что разработчики иногда не хотят уходить на юнит-уровень или пренебрегают UI уровнем. Это не плохо и не хорошо — повторюсь, что главная цель тестов — это уверенность. И набора быстрых и эффективных интеграционных тестов может быть достаточно, чтобы эту уверенность предоставить. Однако есть опасность, что эти тесты со временем либо будут медленнее и медленнее, либо просто начнут тестировать компоненты в изоляции, вместо интеграции.

Интеграционные тесты могут запустить приложение, как есть (@SpringBootTest), либо его отдельный компонент (JPA, Web). Чтобы написать сфокусированный тест для JPA — для этого нет необходимости конфигурировать контроллеры или любые другие компоненты. За это в Spring Boot Test отвечает аннотация ***@DataJpaTest. Это мета-аннотация, т.е. она комбинирует сразу несколько разных аннотаций, конфигурирующих разные аспекты теста.***
#### 1) @AutoConfigureDataJpa <a name="introduction1"></a>
- Просто конфигурирует кэш на использование NoOpCacheManager — т.е. не кешировать ничего. Это полезно, чтобы избежать сюрпризов в тестах.

#### 2) @AutoConfigureTestDatabase <a name="introduction2"></a>
- Это один из самых интересных аспектов JPA теста. Эта конфигурация ищет в classpath одну из поддерживаемых embedded баз данных и переконфигурирует контекст, чтобы DataSource указывал на случайно созданную in-memory базу. Так как я добавил зависимость на H2 базу — то больше делать ничего не нужно, просто наличие этой аннотации автоматически для каждого запуска теста предоставит пустую базу, и это просто невероятно удобно.
Стоит помнить, что эта база будет полностью пустой, без схемы. Чтобы сгенерить схему, есть пара вариантов
Использовать фичу Auto DDL из Hibernate. Spring Boot Test автоматически поставит это значение в create-drop, чтобы Hibernate генерировал схему из описание сущностей и удалял ее в конце сессии. Это невероятно мощная фича Hibernate, которая очень полезна для тестов.
Использовать миграции созданные Flyway или Liquibase.

| ANY | AUTO_CONFIGURED | NONE |
|:----------------|:---------:|:----------------:|
| Заменяет любой компонент DataSource (автоматически или вручную) | Заменяет только автоматически настроенный источник данных | Не заменяет источник данных по умолчанию для приложения |
#### 3) **@AutoConfigureCache** <a name="introduction3"></a>
- Просто конфигурирует кэш на использование NoOpCacheManager — т.е. не кешировать ничего. Это полезно, чтобы избежать сюрпризов в тестах.
#### 4) @AutoConfigureTestEntityManager <a name="introduction4"></a>
- Добавляет в контекст специальный объект TestEntityManager, который сам по себе интересный зверь. EntityManager это главный класс JPA, который отвечает за добавление сущностей в сессию, удаление и подобными вещами. Только вот когда, например, в работу вступает Hibernate — добавление сущности в сессию не значит, что будет выполнен запрос в базу, а загрузка из сессии не означает, что будет выполнен select запрос. За счет внутренних механизмов Hibernate реальные операции с базой будут выполнятся в подходящий момент, который определит сам фреймворк. Но в тестах может быть необходимость принудительно послать что-то в базу, ведь цель тестов как раз тестировать интеграцию. И TestEntityManager это просто хелпер, который поможет некоторые операции с базой принудительно выполнится — например, persistAndFlush() заставит Hibernate выполнить все запросы.
#### 5) @Transactional <a name="introduction5"></a>
- Эта аннотация делает все тесты в классе транзакционными, с автоматическим откатом транзакции по завершению теста. Это просто механизм “очистки” базы перед каждым тестом, ведь иначе пришлось бы вручную удалять данные из каждой таблицы.

#### ROLLBACK (от roll back — англ. откатывать, возвращаться) — оператор языка SQL, который применяется для того, чтобы: <a name="introduction6"></a>
- отменить все изменения, внесённые начиная с момента начала транзакции или с какой-то точки сохранения (SAVEPOINT);
- очистить все точки сохранения данной транзакции;
- завершить транзакцию;
= освободить все блокировки данной транзакции.
________________

## 2 Security <a name="security"></a>

#### UserDetails <a name="security1"></a>
- UserDetails предоставляет необходимую информацию для построения объекта Authentication из DAO объектов приложения или других источников данных системы безопасности. Объект UserDetails содержит имя пользователя, пароль, флаги: isAccountNonExpired, isAccountNonLocked, isCredentialsNonExpired, isEnabled и Collection — прав (ролей) пользователя.
- GrantedAuthority отражает разрешения выданные пользователю в масштабе всего приложения, такие разрешения (как правило называются «роли»), например ROLE_ANONYMOUS, ROLE_USER, ROLE_ADMIN.

| Modifier and Type | Method | Description |
|:----------------:|:---------:|:---------:|
| java.util.Collection<? extends GrantedAuthority> | По getAuthorities() | Возвращает полномочия, предоставленные пользователю | 
| java.lang.String | getPassword() | Возвращает пароль, используемый для аутентификации пользователя | 
| java.lang.String | getUsername() | Возвращает имя пользователя, используемое для аутентификации пользователя | 
| boolean | isAccountNonExpired()| Указывает, истек ли срок действия учетной записи пользователя | 
| boolean | isAccountNonLocked() | Указывает, заблокирован пользователь или разблокирован | 
| boolean | isCredentialsNonExpired() | Указывает, истек ли срок действия учетных данных (пароля) пользователя | 
| boolean | isEnabled() | Указывает, включен или отключен пользователь | 

 #### UserDetailsService <a name="security2"></a>
 - В интерфейсе UserDetailService есть только один метод, который получает строку и возвращает объект UserDetails.При успешной аутентификации UserDetails будет использоваться для создания объекта Authentication и сохранения его в SecurityContextHolder.
 1) **UserDetails loadUserByUsername(string username) throws UsernameNotFoundException;**
 - Реализация UserDetailsService в основном используется для загрузки информации о пользователе и предоставления этой информации другим компонентам. Она не может аутентифицировать пользователя. Операция аутентификации завершается AuthenticationManager. Если пользователи хотят настроить процесс аутентификации, им необходимо реализовать интерфейс AuthenticationProvider.
 
 **Spring's Security DaoAuthenticationProvider** - это простой провайдер аутентификации, который использует объект доступа к данным (DAO) для извлечения информации о пользователе из реляционной базы данных. Он использует UserDetailsService(как DAO) для поиска имени пользователя, пароля и GrantedAuthoritys. Он аутентифицирует пользователя, просто сравнивая пароль, представленный в файле, с паролем, UsernamePasswordAuthenticationToken загруженным в UserDetailsService
 
**Class HttpSecurity :** https://docs.spring.io/autorepo/docs/spring-security/3.2.3.RELEASE/apidocs/org/springframework/security/config/annotation/web/builders/HttpSecurity.html
_______




### JPQL - Java Persistence Query Language <a name="jpql"></a>
***Java Persistence Query Language (JPQL)*** — платформо-независимый объектно-ориентированный язык запросов являющийся частью спецификации JPA.

***JPQL*** используется для написания запросов к сущностям, хранящимся в реляционной базе данных. JPQL во многом похож на SQL, но в отличие от последнего, оперирует запросами, составленными по отношению к сущностям JPA, в отличие от прямых запросов к таблицам базы данных. В дополнение к получению объектов (запросы SELECT), JPQL поддерживает запросы, основанные на операторах UPDATE и DELETE. JPA реализует концепцию ORM.

***JPQL*** основан на Hibernate Query Language (HQL), более раннем не стандартизованном языке запросов, включённом в библиотеку объектно-реляционного отображения Hibernate. Hibernate и HQL были созданы до появления спецификации JPA. JPQL является подмножеством языка запросов HQL

@Query("SELECT u FROM User u WHERE u.email = ?1")
    User findByEmail(String email);
    
 ***Мы также можем использовать собственный SQL для определения нашего запроса. Все, что нам нужно сделать, это установить для атрибута nativeQuery значение true и определить собственный SQL-запрос в атрибуте value аннотации:***
 
 @Query(
  value = "SELECT * FROM User u WHERE u.email = ?1", 
  nativeQuery = true)
 User findByEmail(String email);
